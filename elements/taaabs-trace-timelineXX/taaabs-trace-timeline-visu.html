<dom-module id="taaabs-trace-timeline-visu">

  <style>
    :host {
      display: block;
    }

    :host #pixijs {
      width: 100%;
    }
  </style>

  <template>
    <pixi-js-component id="pixijs" flex-width></pixi-js-component>
  </template>

  <script>
    Polymer({
      is: 'taaabs-trace-timeline-visu',

      /**
       * Fired if the `begin` slider of the ZoomLine has been moved.
       * Fired when mouseup.
       *
       * @event zlBeginMoved
       */

      /**
       * Fired if the `end` slider of the ZoomLine has been moved.
       * Fired when mouseup.
       *
       * @event zlEndMoved
       */

      /**
       * Fired if the whole slider of the ZoomLine has been moved.
       * Fired when mouseup.
       *
       * @event zlGlobalMoved
       */

      properties: {

        ////////////////////////////
        // RENDERER TYPE, FOR GPU //
        ////////////////////////////

        /**
         * True, uses an OpenGL renderer.
         * False, uses a simple canvas.
         *
         * @attribute openGl
         * @type Boolean
         */
        openGl: {
          type: Boolean,
          notify: true,
          value: false
        },

        ///////////////////////
        // GLOBAL ATTRIBUTES //
        ///////////////////////

        _width: {
          type: String,
          notify: true,
          value: "1000px"
        },

        /**
         * The list of obsels to display.
         *
         * @attribute obsels
         * @type Array
         */
        obsels: {
          type: Array,
          notify: true,
          value: function() {
            return [];
          }
        },

        /**
         * Begin time of the trace.
         *
         * @attribute begin
         * @type Number
         */
        begin: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * End time of the trace.
         *
         * @attribute end
         * @type Number
         */
        end: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * Template for the shape of each obsel.
         *
         * @attribute styleTemplate
         * @type Object
         */
        styleTemplate: {
          type: String,
          notify: true,
          value: null,
          observer: '_createStyleArray'
        },

        _styleTemplateArray: {
          type: Object,
          notify: true,
          value: function() {
            return [];
          }
        },

        /**
         * The main PIXI.Container.
         *
         * @attribute _stage
         * @type Object
         */
        _stage: {
          type: Object,
          notify: true,
          value: function() {
            return {};
          }
        },

        /**
         * The main PIXI.Renderer.
         *
         * @attribute _renderer
         * @type Object
         */
        _renderer: {
          type: Object,
          notify: true,
          value: function() {
            return {};
          }
        },

        //////////////////////////////
        // Trace DISPLAY ATTRIBUTES //
        //////////////////////////////

        /**
         * The list of obsels currently displayed.
         *
         * @attribute _obselsDisplayed
         * @type Array
         */
        _obselsDisplayed: {
          type: Array,
          notify: true,
          value: function() {
            return [];
          }
        },

        /**
         * True if the user clicks on an obsel.
         *
         * @attribute _clickOnObsel
         * @type Boolean
         */
        _clickOnObsel: {
          type: Boolean,
          notify: true,
          value: false
        },

        grad: {
          type: Array,
          notify: true,
          value: []
        }
      },

      listeners: {

      },

      ready: function() {},

      ///////////////////////
      // UTILITY FUNCTIONS //
      ///////////////////////

      /**
       * Change `_width` according to the pixi width.
       *
       * @method _onPixiJsResize
       */
      _onPixiJsResize: function() {
        this.async(function(evt) {
          this.set('_width', this.$.pixijs.clientWidth);
          this.updateVisu();
        }.bind(this), 500);
      },

      /**
       * Return the width of the pixijs component (in pixels).
       *
       * @method _getWidth
       */
      _getWidth: function() {
        return this._width;
      },

      /**
       * Return the height of the visu.
       *
       * @method _getHeight
       */
      _getHeight: function() {
        return 215;
      },

      /**
       * Initialize the visualization.
       *
       * @method initVisu
       */
      initVisu: function() {
        this.$.pixijs.set('height', this._getHeight());
        this.$.pixijs.init({
          antialias: true
        });
        // Listen to pixi resize.
        this.listen(this.$.pixijs, 'iron-resize', '_onPixiJsResize');
        this.set('_width', this.$.pixijs.clientWidth);

        this._initZoomArea();
        this._initZoomFocusArea();

        ////////////////
        // RULER INIT //
        ////////////////

        for (var i = 0; i < Math.floor(this._getWidth() / 10); i++) {
          this.push('grad', this.$.pixijs.createRectangleFill(-1, 0, 2, this._getHeight(), 0xDADFE1));
          this.$.pixijs.addToStage(this.grad[i]);
        }

        console.log("initVisu fini");

      },

      updateVisu: function() {
        this.$.pixijs.clearStage();
        this._initZoomArea();
        this._initZoomFocusArea();
        for (var i = 0; i < Math.floor(this._getWidth() / 10); i++) {
          this.push('grad', this.$.pixijs.createRectangleFill(-1, 0, 2, this._getHeight(), 0xDADFE1));
          this.$.pixijs.addToStage(this.grad[i]);
        }
        var obsels = [];

        /*
        for(i = 0 ; i < this._obselsDisplayed.length; i++){
          for(var j = 0 ; j < this._obselsDisplayed[i].length; j++){
            if( this._obselsDisplayed[i][j].obsel )
              obsels.push( this._obselsDisplayed[i][j].obsel);
          }
        }*/
        this.set('_obselsDisplayed', []);
        this.displayObsels(this._begin, this._end, this.obsels);

      },

      /**
       * Initialize the zoom area and its events.
       *
       * @method _initZoomArea
       */
      _initZoomArea: function() {
        this.set('_zoomArea', this.$.pixijs.createRectangleFill(0, 0, this._getWidth(), this._getHeight(), 0xffffff));
        this._zoomArea.interactive = true;
        // Pointer on this
        var that = this;
        this._zoomArea.on('mousedown', function(event) {
          this.data = event.data;
          this.dragging = true;
          this._deltaPos = this.data.getLocalPosition(this.parent).x - this.position.x;
          that._zoomFocusArea.position.x = this.data.getLocalPosition(this.parent).x - 10;
          if (that._zoomFocusArea.position.x < 0) that._zoomFocusArea.position.x = 0;
        });

        this._zoomArea.on('mousemove', function() {
          if (this.dragging && !that._clickOnObsel) {
            that._zoomFocusArea.width = this.data.getLocalPosition(this.parent).x - that._zoomFocusArea.position.x;
          }
        });
        this._zoomArea.on('mouseup', function() {
          if (this.dragging && !that._clickOnObsel) {
            this.dragging = false;
            that._zoomFocusArea.width = this.data.getLocalPosition(this.parent).x - that._zoomFocusArea.position.x;

            if (that._zoomFocusArea.width < 0) {
              var posB = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              if (posB < 0)
                posB = 0;
              var posE = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            } else if (that._zoomFocusArea.width > 0) {
              var posE = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              var posB = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            }

          }
        });
        this._zoomArea.on('mouseupoutside', function() {
          if (this.dragging) {
            this.dragging = false;
            that._zoomFocusArea.width = this.data.getLocalPosition(this.parent).x - that._zoomFocusArea.position.x;

            if (that._zoomFocusArea.width < 0) {
              var posB = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              if (posB < 0)
                posB = 0;
              var posE = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            } else if (that._zoomFocusArea.width > 0) {
              var posE = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              var posB = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            }
          }
        });

        this.$.pixijs.addToStage(this._zoomArea);
      },

      /**
       * Initialize the zoom focus area and its events.
       *
       * @method _initZoomFocusArea
       */
      _initZoomFocusArea: function() {
        this._zoomFocusArea = this.$.pixijs.createRectangleFill(0, 0, 1, this._getHeight(), 0x4183D7);
        this.$.pixijs.setParameters(this._zoomFocusArea, {
          'alpha': 0.5
        });
        this.$.pixijs.addToStage(this._zoomFocusArea);
      },

      _createStyleArray: function() {
        function getDirectives(s) {
          return s.match(/([\s\S]*?){([\s\S]*?)}/g);
        }

        function getType(s) {
          var matches = s.match(/#[\S]*/g);
          return ((matches) ? matches[0].replace('#', '') : null);
        }

        function getAttributes(s) {
          return s.match(/\.[\S]*?\[[\S\s]*?\]/g);
        }

        function getAttribute(s) {
          return s.split('[')[0].replace('.', '');
        }

        function getAttributeValues(s) {
          return s.match(/\[[\S\s]*?\]/)[0].replace('[', '').replace(']', '');
        }

        function getAttributeOperator(s) {
          var matches = s.split(',');
          return ((matches.length > 1) ? matches[0].replace(/"/g, '') : null);
        }

        function getAttributeValue(s) {
          var matches = s.split(',');
          var match = ((matches.length > 1) ? matches[1] : matches[0]);
          return match.replace(/"/g, '');
        }

        function getSelector(s) {
          return s.split('{')[0];
        }

        function getDeclarations(s) {
          return s.match(/{[\s\S]*?}/)[0].replace(/[{}\s\n]/g, '').split(',');
        }

        function getDeclaration(s) {
          return s.split(':');
        }

        this.set('_styleTemplateArray', []);
        var s = this.styleTemplate;

        if (s) {
          var directives = getDirectives(s);
          for (var i = 0; i < directives.length; i++) {
            var tmpStyle = {};
            var selector = getSelector(directives[i]);
            tmpStyle.type = getType(selector);
            var attributes = getAttributes(selector);

            if (attributes) {
              tmpStyle.attributes = [];
              for (var j = 0; j < attributes.length; j++) {
                var tmpAttribute = {};
                tmpAttribute.name = getAttribute(attributes[j]);
                var attributeValues = getAttributeValues(attributes[j]);
                tmpAttribute.operator = getAttributeOperator(attributeValues);
                tmpAttribute.value = getAttributeValue(attributeValues);
                tmpStyle.attributes.push(tmpAttribute);
              }
            }

            var declarations = getDeclarations(directives[i]);
            tmpStyle.symbol = {};
            for (var k = 0; k < declarations.length; k++) {
              var declaration = getDeclaration(declarations[k]);
              tmpStyle.symbol[declaration[0]] = declaration[1];
            }

            this.push('_styleTemplateArray', tmpStyle);
          }
        }
      },

      /////////////////////////////
      // Trace DISPLAY FUNCTIONS //
      /////////////////////////////

      /**
       * Returns a `Pixi.Graphics` object with the shape and color of an obsel.
       *
       * @param {!required} obsel (Object) The obsel to display.
       * @param {!required} size (Number) The size in pixel.
       * @param {!required} position (Pixi.Point) The position of the obsel.
       *
       * @method _getObselShape
       */
      _getObselShape: function(obsel, size, position) {

        if (this.styleTemplate === null || this._styleTemplateArray.length === 0)
          return this.$.pixijs.createRectangleFill(position.x, position.y, size, size, 0x22A7F0);
        else {
          var directive = {};
          for (var i = this._styleTemplateArray.length - 1; i >= 0; i--) {
            var isInRange = true;
            if (this._styleTemplateArray[i].type)
              if (this._styleTemplateArray[i].type !== obsel['@type'])
                isInRange = false;

            var j = 0;
            while (isInRange && this._styleTemplateArray[i].attributes && j < this._styleTemplateArray[i].attributes.length) {
              if (obsel[this._styleTemplateArray[i].attributes[j].name]) {
                if (this._styleTemplateArray[i].attributes[j].operator) {
                  var attrVal = Number(obsel[this._styleTemplateArray[i].attributes[j].name]);
                  var styleVal = Number(this._styleTemplateArray[i].attributes[j].value);
                  if (isNaN(attrVal))
                    isInRange = false;
                  else {
                    switch (this._styleTemplateArray[i].attributes[j].operator) {
                      case '>':
                        if (attrVal <= styleVal)
                          isInRange = false;
                        break;
                      case '>=':
                        if (attrVal < styleVal)
                          isInRange = false;
                        break;
                      case '<':
                        if (attrVal >= styleVal)
                          isInRange = false;
                        break;
                      case '<=':
                        if (attrVal > styleVal)
                          isInRange = false;
                        break;
                    }
                  }
                } else {
                  if (obsel[this._styleTemplateArray[i].attributes[j].name] !== this._styleTemplateArray[i].attributes[j].value)
                    isInRange = false;
                }
              } else {
                isInRange = false;
              }
              j++;
            }
            if (isInRange) {
              if (Object.keys(directive).length === 0) {
                directive = this._styleTemplateArray[i];
              } else {

                var weight = 0;

                if (directive.type)
                  weight += 1;
                if (this._styleTemplateArray[i].type)
                  weight -= 1;
                if (this._styleTemplateArray[i].attributes && this.styleTemplateArray[i].attributes.length > directive.attributes.length + weight)
                  directive = this._styleTemplateArray[i];
              }
            }

            if (this._styleTemplateArray[i].type === "DEFAULT_GLOBAL_SYMBOL" && Object.keys(directive).length === 0)
              directive = this._styleTemplateArray[i];
          }

          if (Object.keys(directive).length === 0 || directive.symbol.enabled === 'false')
            return null;

          var color = parseInt(directive.symbol.color.replace(/^#/, ''), 16);

          switch (directive.symbol.shape) {
            case 'SQUARE':
              return this.$.pixijs.createRectangleFill(position.x, position.y, size, size, color);
              break;
            case 'CIRCLE':
              return this.$.pixijs.createCircleFill(position.x + size / 2, position.y + size / 2, size / 2, color);
              break;
            case 'DIAMOND':
              return this.$.pixijs.createDiamondFill(position.x, position.y, size, size, color);
              break;
            case 'STAR':
              return this.$.pixijs.createStarFill(position.x, position.y, size, color);
              break;
            default:
              return this._getImage(size, position, directive.symbol.img);
              break;
          }

        }
      },

      /**
       * Displays a list of obsels, between a 'begin' & 'end'.
       *
       * @param {!required} start (Object) The beginning of the interval to display.
       * @param {!required} end (Number) The end of the interval to display.
       * @param {!required} obsels (Array) An array of obsels.
       *
       * @method displayObsels
       */
      displayObsels: function(start, end, obsels) {

        var that = this;

        this._begin = start;
        this._end = end;

        var d = new Date(start);

        d = new Date(end);

        // The size of the obsels (10px if there's more than 50 obsels, 20px otherwise)
        var obselSize = 0;

        // We remove the previous obsels drew
        for (var i = 0; i < this._obselsDisplayed.length; i++) {
          for (var j = 0; j < this._obselsDisplayed[i].length; j++) {
            this.$.pixijs.removeChildFromStage(this._obselsDisplayed[i][j]);
          }
        }

        // A list of list of obsels.
        // Each list represent an interval, for 10 or 20 obsels to be displayed.
        this.set('_obselsDisplayed', []);

        // If we have less then 50 obsels, we draw big obsels on 50 intervals.
        // Otherwise, we draw small obsels on 100 intervals.

        for (var i = 0; i < Math.floor(this._getWidth() / 10); i++) {
          this._obselsDisplayed.push([]);
        }
        obselSize = 10;

        // For each obsels, we stack them on their corresponding intervals.
        for (var i = 0; i < obsels.length; i++) {

          // X = (Position.end - Position.begin)/ (Time.end - Time.begin) * (Time - Time.begin) + Position.begin;
          // TODO changement de la position des obsels
          var pixelPos = ((this._getWidth() - 20 - 0) / (end - start)) * (obsels[i].end - start) + 0;
          //var pixelPos = ( (1000 - 0) / (end - start) ) * ( obsels[i].end - start ) + 0;

          // The index of the interval in 'obsels'.
          var arrayPos = Math.floor(pixelPos / obselSize);

          var max = 20;

          // If we still got room in a stack.
          if (this._obselsDisplayed[arrayPos].length < max) {

            var posy = 0;
            posy = 200 - (obselSize + 1) * this._obselsDisplayed[arrayPos].length;

            var obs = this._getObselShape(obsels[i],
              obselSize,
              new PIXI.Point(arrayPos * obselSize + 5, posy));

            if (obs !== null) {

              obs.interactive = true;
              obs.buttonMode = true;
              obs.obsel = obsels[i];

              obs.on('mousedown', function() {
                  that._clickOnObsel = true;
                })
                .on('mouseup', function() {
                  that.fire('obselClicked', {
                    "obs": this.obsel
                  });
                  that._clickOnObsel = false;
                })
                .on('mouseupoutside', function() {
                  that._clickOnObsel = false;
                })

              this.$.pixijs.addToStage(obs);

              this._obselsDisplayed[arrayPos].push(obs);
            }
          }
        }
      },

    });
  </script>
</dom-module>
